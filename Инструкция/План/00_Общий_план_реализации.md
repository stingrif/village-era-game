# Общий план реализации проекта

Единая точка входа по задачам реализации. Переход к следующей фазе и завершение плана допустимы **только после успешного прохождения шлюза работоспособности** текущей фазы. Согласовано с [06_Правила_проверки_для_ИИ](../Сервисы/06_Правила_проверки_для_ИИ.md) и [.cursorrules](../../.cursorrules).

---

## Принцип «шлюз работоспособности»

- **Шлюз:** запуск релевантных тестов и при необходимости ручная проверка (API, фронт, деплой); все проверки должны быть зелёными.
- **При провале:** исправить причину, снова запустить проверки; **не переходить к следующим задачам** до успешного прохождения.
- Выход из цикла планирования допустим **только при подтверждённой работоспособности** приложения (тесты зелёные, smoke пройден, деплой отвечает).

---

## Фаза 0. Стабилизация: тесты и базовая работоспособность

**Задачи:**

- [x] 1. Привести ответ API `POST /api/game/mine/dig` в соответствие с тестом: в ответе поле `opened_cells` (или изменить тест под текущий контракт; решение зафиксировать в [18_Dev](../18_Dev_таблицы_и_формулы.md) или в тесте). См. бэкенд/tests/test_game_api_e2e.py и реализацию mine_dig.
- [x] 2. Запустить полный набор тестов бэкенда (`pytest tests/`); устранить все падающие тесты и предупреждения (например PytestReturnNotNoneWarning в test_mine_create).
- [x] 3. Проверить локальный подъём приложения (uvicorn + при необходимости фронт): главная открывается, чекин/шахта отвечают по API.
- [x] 4. Обновить при необходимости [СООТВЕТСТВИЕ_АРХИТЕКТУРЕ](../../бэкенд/СООТВЕТСТВИЕ_АРХИТЕКТУРЕ.md) и [28_Статус_и_задачи](../28_Статус_и_задачи.md) по результатам.

**Шлюз Фазы 0:** Все тесты бэкенда зелёные; ручная проверка: GET /api/game/config и POST /api/game/checkin (или mine) возвращают ожидаемые ответы. **Переход к Фазе 1 только после этого.**

---

## Фаза 1. Микросервис секретов

**Задачи:**

- [ ] 1. Создать папку сервиса (Игра/сервисы/secrets/ или Игра/deploy/secrets/): один сервис — одна папка.
- [ ] 2. Реализовать API по [04_Сервис_секретов](../Сервисы/04_Сервис_секретов.md): GET /secret?key=... с проверкой заголовка (X-Internal-Token или доступ только из внутренней сети); ответ `{"value": "..."}` или 403/404.
- [ ] 3. Хранение: чтение из os.environ или из файла (SECRETS_FILE); не логировать значения.
- [ ] 4. Dockerfile и requirements.txt в папке сервиса; порт (например 8003) в env.
- [ ] 5. Добавить сервис в docker-compose; проверить, что контейнер стартует и отвечает на /secret при валидном ключе.
- [ ] 6. При необходимости дополнить 04_Сервис_секретов.md фактическим форматом запроса/ответа.

**Шлюз Фазы 1:** Контейнер secrets запускается; запрос к /secret с валидным key и токеном возвращает 200 и value. Тесты бэкенда зелёные. **Переход к Фазе 2 только после этого.**

---

## Фаза 2. Микросервис авторизации

**Задачи:**

- [ ] 1. Создать папку сервиса (Игра/сервисы/auth/).
- [ ] 2. Реализовать POST /verify по [03_Сервис_авторизации_и_аутентификации](../Сервисы/03_Сервис_авторизации_и_аутентификации.md): тело `{"init_data": "..."}` или `{"token": "..."}`; проверка подписи Telegram или JWT; при успехе — ответ `{"user_id": int}`; при ошибке — 401.
- [ ] 3. Получение ключа для проверки подписи — вызов сервиса секретов (SECRETS_SERVICE_URL, INTERNAL_TOKEN).
- [ ] 4. Dockerfile, requirements, env; добавить в docker-compose; проверить сеть до app и до secrets.
- [ ] 5. Тесты или ручной сценарий для /verify с валидными и невалидными данными.

**Шлюз Фазы 2:** Сервис auth отвечает на /verify; при валидном init_data возвращает user_id; при невалидном — 401. **Переход к Фазе 3 только после этого.**

---

## Фаза 3. Микросервис сессий

**Задачи:**

- [ ] 1. Создать папку сервиса (Игра/сервисы/sessions/).
- [ ] 2. Реализовать эндпоинты по [02_Сервис_сессий](../Сервисы/02_Сервис_сессий.md): POST /session (создать), POST /session/refresh (продлить), POST /session/invalidate (инвалидировать), GET /session/validate?session_id=... (проверить). Хранение: Redis или БД; TTL/expires_at.
- [ ] 3. Ключ подписи сессий запрашивать у сервиса секретов (SESSION_SIGNING_KEY).
- [ ] 4. Dockerfile, requirements, env (REDIS_URL или DATABASE_URL, SECRETS_SERVICE_URL); добавить в docker-compose.
- [ ] 5. Тесты или ручные сценарии: создание сессии, validate, refresh, invalidate.

**Шлюз Фазы 3:** Создание сессии возвращает session_id; validate возвращает user_id при валидной сессии; invalidate делает сессию невалидной. **Переход к Фазе 4 только после этого.**

---

## Фаза 4. Интеграция бэкенда Игра с Auth и Sessions (опционально)

**Задачи:**

- [ ] 1. Решить: оставить текущую схему (auth по telegram_id) или перевести защищённые эндпоинты на Auth + Sessions. Если нет — фазу пометить «пропуск».
- [ ] 2. При переводе: в бэкенде вызывать Auth /verify или Sessions /session/validate; получать user_id; не дублировать проверку initData в app.
- [ ] 3. Конфиг: AUTH_SERVICE_URL, SESSIONS_SERVICE_URL; обновить env.example.
- [ ] 4. Прогнать все тесты; проверить сценарий: запрос с валидной сессией/токеном → 200, без — 401.

**Шлюз Фазы 4:** Все тесты зелёные; сценарий входа/сессии работает по выбранной схеме. **Переход к Фазе 5 только после этого.**

---

## Фаза 5. Тигрит: общий слой и веб-API

**Задачи:**

- [x] 1. Создать в кабзда пакет tigrit_shared: db.py (пул asyncpg, query_one, query_all, execute), read.py (get_village_row, get_top_users, get_recent_events по tigrit_*).
- [x] 2. Бот Тигрит: перевести использование пула и чтения на tigrit_shared; в db_async оставить ensure_user, ensure_tigrit_profile, запись в tigrit_*.
- [x] 3. Веб-API Тигрит: убрать SQLite; async и вызовы tigrit_shared; GET /api/village, /api/users, /api/events; /api/map и /api/assets — заглушки.
- [x] 4. Фронт Тигрит: API_URL на относительный `/api` (или VITE_API_BASE при сборке).
- [x] 5. Сборка фронта (npm run build); проверить локально, что API отдаёт данные из PostgreSQL.

**Шлюз Фазы 5:** Бот стартует с tigrit_shared; веб-API отвечает на /api/village, /api/users, /api/events; фронт собирается. **Переход к Фазе 6 только после этого.**

---

## Фаза 6. Тигрит: деплой веб (tigrit-api, tigrit-web, nginx)

**Задачи:**

- [x] 1. В Игра/deploy: папки tigrit_api и tigrit_web. Dockerfile tigrit_api: Python, tigrit_shared + backend. Dockerfile tigrit_web: сборка фронта (Vite), nginx с dist и proxy /api на tigrit-api.
- [x] 2. docker-compose: сервисы tigrit-api и tigrit-web; env DATABASE_URL, сеть game.
- [x] 3. nginx-docker.conf: второй server для tigrit.stakingphxpw.com; location / → proxy_pass на tigrit-web.
- [x] 4. Проверить: после docker compose up запрос к поддомену отдаёт статику и /api проксируется на tigrit-api (проверка в deploy_docker_on_149.sh и verify_after_deploy.sh).

**Шлюз Фазы 6:** tigrit-api и tigrit-web поднимаются; по поддомену открывается веб Тигрит и данные подгружаются. **Переход к Фазе 7 только после этого.**

---

## Фаза 6.1. Полное наполнение веб-интерфейса Тигрит (кабзда → deploy)

**Цель:** Подключить полные данные (карта, ассеты, активные ивенты, команды бота), убрать заглушки в API, синхронизировать кабзда с deploy.

**Выполнено:**

- [x] 1. **tigrit_shared/read.py:** функция `get_active_events(limit)` — выборка из `tigrit_events` WHERE status='active' (id, title, effect_*, chat_id, message_id, start_ts, end_ts, status).
- [x] 2. **Backend data:** папка `кабзда/tigrit_web/backend/data/` с `tile_data.json`, `building_data.json`, `character_data.json`, `village_map.json` (32×32, площадь + 14 зданий).
- [x] 3. **Backend API (кабзда и deploy):** `/api/assets` — чтение из data/, ответ `{ tiles, buildings, characters }` (полные объекты); `/api/map` — village_map.json; GET `/api/events/active` — вызов `get_active_events()`.
- [x] 4. **Фронт:** карта и редактор используют цвет из ассетов по id/name; блок «Активные ивенты» (запрос `/api/events/active`, список с названием, временем окончания, ссылкой «В бот»); блок «Команды бота» (статический список: /start, /top, /village, /me, /balance, /friends, /spawn_event); отдельная вкладка «Команды бота».
- [x] 5. **Синхронизация кабзда → deploy:** в `Игра/deploy/tigrit_api` — tigrit_shared с `get_active_events`, backend/data/ с четырьмя JSON; в `Игра/deploy/tigrit_web/frontend` — актуальные main.js, index.html, styles.css.

**Проверить (шлюз Фазы 6.1):**

- [ ] 1. **Локально (кабзда):** запустить backend (`uvicorn` из `кабзда/tigrit_web/backend`), проверить GET `/api/assets` — в ответе массивы объектов с id, name, color (tiles/buildings) и characters; GET `/api/map` — width, height, tiles; GET `/api/events/active` — массив (может быть пустой).
- [ ] 2. **Фронт кабзда:** открыть веб, вкладки «Деревня» — карта рисуется цветными тайлами по типам; «События» — блок «Активные ивенты» и список команд; «Редактор» — в панели слева тайлы/здания/персонажи с названиями и цветами, выбор и расстановка по клику.
- [ ] 3. **Deploy:** после `docker compose up` в deploy — запрос к tigrit-api на `/api/assets`, `/api/map`, `/api/events/active` возвращает те же форматы; веб по поддомену показывает карту, ивенты и команды без ошибок в консоли.

**Результаты автоматической проверки (код и данные):**

- **deploy/tigrit_api:** все 4 JSON в `backend/data/` на месте; загрузка даёт tiles: 4, buildings: 14, characters: 12 (races+classes), map 32×32 с 15 тайлами. В `main.py` — эндпоинты `/api/assets`, `/api/map`, `/api/events/active`; в `tigrit_shared/read.py` — `get_active_events`.
- **кабзда/tigrit_web/backend/data:** те же 4 файла; tile_data 4, building_data 14, character_data 5 races + 7 classes, village_map 15 тайлов.
- **deploy/tigrit_web/frontend:** в `main.js` — `activeEvents`, `botCommands`, `getColorForTileType`, запрос `events/active`; в `index.html` — вкладка «Команды бота», блоки «Активные ивенты» и «Команды бота» на вкладке «События».

**Остаётся вручную:** запуск backend (с валидным DATABASE_URL для `/api/events/active`), открытие фронта в браузере, `docker compose up` и проверка поддомена.

**Шлюз Фазы 6.1:** API отдаёт полные ассеты и карту; фронт отображает карту по данным API, активные ивенты и команды бота; кабзда и deploy синхронны. **Переход к Фазе 7 только после проверки.**

---

## Фаза 7. Деплой и маршрутизация (149 / прод)

**Задачи:**

- [ ] 1. На целевом сервере: Caddy/nginx прокси tigrit.stakingphxpw.com; при необходимости обновить deploy/caddy-tigrit.conf.example.
- [ ] 2. Выгрузка (upload_to_149_docker.sh) и деплой (deploy_docker_on_149.sh); все контейнеры (app, api-gateway, health, tigrit-bot, tigrit-api, tigrit-web, redis) в состоянии running.
- [ ] 3. Smoke: https://stakingphxpw.com — игра; https://tigrit.stakingphxpw.com — веб Тигрит; бот в Telegram отвечает.
- [ ] 4. Обновить README_DOCKER_149.md и при необходимости 28_Статус_и_задачи.

**Шлюз Фазы 7:** На целевом окружении сайт и поддомен открываются; бот отвечает. **Переход к Фазе 8 только после этого.**

---

## Фаза 8. Документация и финальный шлюз

**Задачи:**

- [ ] 1. Обновить [25_Архитектура](../25_Архитектура.md): диаграмма с Auth, Sessions, Secrets, Tigrit API/Web; ссылки на Сервисы и План.
- [ ] 2. Обновить [18_Dev](../18_Dev_таблицы_и_формулы.md) при добавлении таблиц/полей в ходе фаз.
- [ ] 3. [СООТВЕТСТВИЕ_АРХИТЕКТУРЕ](../../бэкенд/СООТВЕТСТВИЕ_АРХИТЕКТУРЕ.md): отметить реализованные микросервисы.
- [ ] 4. [28_Статус_и_задачи](../28_Статус_и_задачи.md): перенести выполненное в «Выполнено»; актуализировать «Планируется».

**Финальный шлюз (условие выхода из цикла):**

- Полный прогон тестов бэкенда: все зелёные.
- Ручная проверка (smoke): главная игры, чекин/шахта по API, при необходимости веб Тигрит и бот.
- Деплой в целевом окружении: приложение доступно и отвечает.

**План считается завершённым только при выполнении финального шлюза.**

---

## Дополнительные фазы (Фаза 9 и далее)

- **Расхождения 18_Dev:** dig_log, checkin_log поля; уровень игрока для вывода; ads_rules, donation_rules в конфиге. Задачи и шлюз — по тому же принципу.
- **Вывод TON / Блокчейн:** заглушки iCryptoCheck и TonAPI — отдельные фазы с собственными шлюзами при реализации.
- **Крон-задачи:** стейкинг (награды, разблокировка), блокчейн (monitor_wallets), Skyfall, leaderboards — фаза с задачами и шлюзом (запуск воркера, один цикл без ошибок).

Детали — в [28_Статус_и_задачи](../28_Статус_и_задачи.md) и [СООТВЕТСТВИЕ_АРХИТЕКТУРЕ](../../бэкенд/СООТВЕТСТВИЕ_АРХИТЕКТУРЕ.md).

---

## Чек-лист выхода

План завершён **только при**:

- [ ] Все тесты бэкенда зелёные.
- [ ] Smoke-проверка пройдена (игра, API, при необходимости Тигрит веб и бот).
- [ ] Деплой в целевом окружении рабочий (сайт и поддомен открываются, бот отвечает).

При выполнении фаз сверяться с [06_Правила_проверки_для_ИИ](../Сервисы/06_Правила_проверки_для_ИИ.md) и с этим планом.
