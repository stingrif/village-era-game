# Сервис сессий

Микросервис отвечает только за жизненный цикл сессий: создание, продление, инвалидация, проверка валидности. Не содержит логики авторизации (кто такой пользователь — решает сервис авторизации). Ключ для подписи сессий запрашивает у сервиса секретов.

---

## Назначение

- Создание сессии после успешной идентификации (user_id приходит от вызывающего, который уже получил его у Auth).
- Хранение сессий: Redis или отдельная таблица в БД (session_id, user_id, created_at, expires_at, метаданные по необходимости).
- Продление TTL по session_id.
- Инвалидация по session_id или по user_id (выход, отзыв).
- Проверка: по session_id вернуть user_id и статус (валидна/истекла).

Сервис не проверяет Telegram initData и не выдаёт user_id по токену — только работает с уже выданными session_id и при создании принимает user_id от вызывающего.

---

## Контракт API (эндпоинты)

Базовый URL сервиса задаётся в конфигурации вызывающих (env). Все ответы в JSON.

| Метод | Путь | Назначение | Тело запроса | Ответ |
|-------|------|------------|--------------|--------|
| POST | /session | Создать сессию | `{"user_id": int}` | `{"session_id": str, "expires_at": int (unix)}` или 400/500 |
| POST | /session/refresh | Продлить сессию | `{"session_id": str}` | `{"expires_at": int}` или 401/404 |
| POST | /session/invalidate | Инвалидировать | `{"session_id": str}` или `{"user_id": int}` | `{"ok": true}` или 404 |
| GET  | /session/validate | Проверить сессию | Query: `session_id=...` | `{"valid": true, "user_id": int}` или `{"valid": false}` / 401 |

Коды ошибок: 400 — неверный запрос; 401 — невалидная/истекшая сессия; 404 — сессия не найдена; 500 — внутренняя ошибка.

При создании и продлении сервис подписывает данные ключом, полученным у сервиса секретов (например SESSION_SIGNING_KEY). Формат подписи (HMAC, JWT и т.д.) фиксируется в реализации и в этом документе при необходимости.

---

## Хранилище

- **Вариант A:** Redis — ключ по session_id, значение JSON (user_id, expires_at); TTL по expires_at.
- **Вариант B:** Таблица в PostgreSQL (session_id PK, user_id, created_at, expires_at); фоновое удаление истёкших или по TTL в Redis.

Выбор хранилища и схема — в папке сервиса (см. ниже).

---

## Кто вызывает

- **Бэкенд Игра (app):** создание сессии после проверки пользователя через Auth; проверка сессии на защищённых эндпоинтах.
- **Бот Тигрит:** при необходимости веб-логина — создание/проверка сессии.
- **Tigrit API:** проверка сессии для доступа к данным от имени пользователя.

Все вызывающие должны знать только базовый URL сервиса сессий и контракт выше. Не вызывают друг друга от имени сессий.

---

## Папка в репозитории

Один сервис — одна папка. Например: `Игра/сервисы/sessions/` или `Игра/deploy/sessions/`. Внутри: код приложения (FastAPI/uvicorn или аналог), Dockerfile, requirements.txt, конфиг (env). Обращения к другим сервисам только по HTTP к Secrets (получение ключа подписи); без прямого доступа к БД Игра или Auth.

---

## Переменные окружения (env)

- `DATABASE_URL` или `REDIS_URL` — в зависимости от выбранного хранилища.
- `SECRETS_SERVICE_URL` — базовый URL сервиса секретов (для запроса SESSION_SIGNING_KEY).
- `INTERNAL_TOKEN` или аналог — токен для вызова сервиса секретов (если требуется).
- Порт приложения (например `PORT=8002`).

Другие секреты не хранить в env сервиса сессий — только получать ключ подписи у сервиса секретов.
